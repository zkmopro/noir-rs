/* automatically generated by rust-bindgen 0.71.1 */

pub type out_str_buf = *mut *mut u8;
pub type in_ptr = *const *mut ::std::os::raw::c_void;
pub type out_ptr = *mut *mut ::std::os::raw::c_void;
extern "C" {
    pub fn pedersen_commit(inputs_buffer: vec_in_buf, ctx_index: *const u32, output: out_buf);
}
extern "C" {
    pub fn pedersen_hash(inputs_buffer: *const u8, hash_index: *const u32, output: *mut u8);
}
extern "C" {
    pub fn pedersen_hashes(inputs_buffer: *const u8, hash_index: *const u32, output: *mut u8);
}
extern "C" {
    pub fn pedersen_hash_buffer(input_buffer: *const u8, hash_index: *const u32, output: *mut u8);
}
// extern "C" {
//     pub fn poseidon_hash(inputs_buffer: *const u8, output: *mut u8);
// }
// extern "C" {
//     pub fn poseidon_hashes(inputs_buffer: *const u8, output: *mut u8);
// }
extern "C" {
    pub fn blake2s(data: *const u8, out: *mut u8);
}
extern "C" {
    pub fn blake2s_to_field_(data: *const u8, r: *mut u8);
}
extern "C" {
    pub fn schnorr_construct_signature(
        message_buf: *const u8,
        private_key: *const u8,
        s: *mut u8,
        e: *mut u8,
    );
}
extern "C" {
    pub fn schnorr_verify_signature(
        message_buf: *const u8,
        pub_key: *const u8,
        sig_s: *const u8,
        sig_e: *const u8,
        result: *mut bool,
    );
}
extern "C" {
    pub fn schnorr_multisig_create_multisig_public_key(
        private_key: *const u8,
        multisig_pubkey_buf: *mut u8,
    );
}
extern "C" {
    pub fn schnorr_multisig_validate_and_combine_signer_pubkeys(
        signer_pubkey_buf: *const u8,
        combined_key_buf: *mut u8,
        success: *mut bool,
    );
}
extern "C" {
    pub fn schnorr_multisig_construct_signature_round_1(
        round_one_public_output_buf: *mut u8,
        round_one_private_output_buf: *mut u8,
    );
}
extern "C" {
    pub fn schnorr_multisig_construct_signature_round_2(
        message_buf: *const u8,
        private_key: *const u8,
        signer_round_one_private_buf: *const u8,
        signer_pubkeys_buf: *const u8,
        round_one_public_buf: *const u8,
        round_two_buf: *mut u8,
        success: *mut bool,
    );
}
extern "C" {
    pub fn schnorr_multisig_combine_signatures(
        message_buf: *const u8,
        signer_pubkeys_buf: *const u8,
        round_one_buf: *const u8,
        round_two_buf: *const u8,
        s: *mut u8,
        e: *mut u8,
        success: *mut bool,
    );
}
extern "C" {
    pub fn srs_init_srs(points_buf: *const u8, num_points: *const u32, g2_point_buf: *const u8);
}
extern "C" {
    pub fn srs_init_grumpkin_srs(points_buf: *const u8, num_points: *const u32);
}
extern "C" {
    pub fn examples_simple_create_and_verify_proof(valid: *mut bool);
}
extern "C" {
    pub fn test_threads(threads: *const u32, iterations: *const u32, out: *mut u32);
}
extern "C" {
    pub fn common_init_slab_allocator(circuit_size: *const u32);
}
extern "C" {
    pub fn acir_get_circuit_sizes(
        constraint_system_buf: *const u8,
        recursive: *const bool,
        honk_recursion: *const bool,
        total: *mut u32,
        subgroup: *mut u32,
    );
}
extern "C" {
    pub fn acir_new_acir_composer(size_hint: *const u32, out: out_ptr);
}
extern "C" {
    pub fn acir_delete_acir_composer(acir_composer_ptr: in_ptr);
}
extern "C" {
    pub fn acir_init_proving_key(
        acir_composer_ptr: in_ptr,
        constraint_system_buf: *const u8,
        recursive: *const bool,
    );
}
extern "C" {
    #[doc = " It would have been nice to just hold onto the constraint_system in the acir_composer, but we can't waste the\n memory. Being able to reuse the underlying Composer would help as well. But, given the situation, we just have\n to pass it in everytime."]
    pub fn acir_create_proof(
        acir_composer_ptr: in_ptr,
        constraint_system_buf: *const u8,
        recursive: *const bool,
        witness_buf: *const u8,
        out: *mut *mut u8,
    );
}
extern "C" {
    #[doc = " @brief Construct and verify an UltraHonk proof\n"]
    pub fn acir_prove_and_verify_ultra_honk(
        constraint_system_buf: *const u8,
        recursive: *const bool,
        witness_buf: *const u8,
        result: *mut bool,
    );
}
extern "C" {
    pub fn acir_load_verification_key(acir_composer_ptr: in_ptr, vk_buf: *const u8);
}
extern "C" {
    pub fn acir_init_verification_key(acir_composer_ptr: in_ptr);
}
extern "C" {
    pub fn acir_get_verification_key(acir_composer_ptr: in_ptr, out: *mut *mut u8);
}
extern "C" {
    pub fn acir_get_proving_key(
        acir_composer_ptr: in_ptr,
        acir_vec: *const u8,
        recursive: *const bool,
        out: *mut *mut u8,
    );
}
extern "C" {
    pub fn acir_verify_proof(acir_composer_ptr: in_ptr, proof_buf: *const u8, result: *mut bool);
}
extern "C" {
    pub fn acir_get_solidity_verifier(acir_composer_ptr: in_ptr, out: out_str_buf);
}
extern "C" {
    pub fn acir_serialize_proof_into_fields(
        acir_composer_ptr: in_ptr,
        proof_buf: *const u8,
        num_inner_public_inputs: *const u32,
        out: *mut *mut u8,
    );
}
extern "C" {
    pub fn acir_serialize_verification_key_into_fields(
        acir_composer_ptr: in_ptr,
        out_vkey: *mut *mut u8,
        out_key_hash: *mut u8,
    );
}
extern "C" {
    pub fn acir_prove_ultra_honk(
        acir_vec: *const u8,
        recursive: *const bool,
        witness_vec: *const u8,
        out: *mut *mut u8,
    );
}
extern "C" {
    pub fn acir_verify_ultra_honk(proof_buf: *const u8, vk_buf: *const u8, result: *mut bool);
}
extern "C" {
    pub fn acir_write_vk_ultra_honk(acir_vec: *const u8, recursive: *const bool, out: *mut *mut u8);
}
extern "C" {
    pub fn acir_proof_as_fields_ultra_honk(proof_buf: *const u8, out: vec_out_buf);
}
pub type vec_in_buf = *const u8;
pub type out_buf = *mut u8;
pub type vec_out_buf = *mut *mut u8;
