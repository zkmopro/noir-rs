{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":12629770646657047045,"abi":{"parameters":[{"name":"verification_key","type":{"kind":"array","length":128,"type":{"kind":"field"}},"visibility":"private"},{"name":"proof","type":{"kind":"array","length":463,"type":{"kind":"field"}},"visibility":"private"},{"name":"public_inputs","type":{"kind":"array","length":1,"type":{"kind":"field"}},"visibility":"public"},{"name":"key_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"ZY1LCsMgFEX38sYONClt4lZKCX6DICp+CkXce01ISqDDc+9591WQipd1MU77BPRZwXrBsvGuUwW8Rykwt1HKLGag5DYjUE4CHYa5IdDGKqD3saF/9UGmwyUTJj95xO3VgUdjrVmX688ev1k0jFt1oC5OXNr8CWdz3ofohZIlqm1p7/r8Fw==","file_map":{"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"63":{"source":"use dep::std;\n\nfn main(\n    verification_key: [Field; 128],\n    proof: [Field; 463],\n    public_inputs: pub [Field; 1],\n    key_hash: Field,\n) {\n    std::verify_proof_with_type(verification_key, proof, public_inputs, key_hash, 1);\n}\n","path":"/Users/zhengyawen/Documents/GitHub/noir-rs/circuits/crates/recursive/src/main.nr"}},"names":["main"],"brillig_names":[]}